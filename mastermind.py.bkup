

class GuessChecker(object):
    def __init__(self, pattern_in):
        self.pattern = pattern_in

    def check_guess(self, guess):
        """
        returns (x, y) if nothing matched
        where 
        x denotes number of pegs that have right color but wrong position
        y denotes number of pegs that have right color and position
        """
        x = 0
        y = 0

        #search for pegs with right color and position
        remaining_guesses = []
        remaining_patterns = []
        for (ii,pi) in enumerate(self.pattern):
            if pi == guess[ii]:
                y += 1
            else:
                remaining_patterns.append(pi)
                remaining_guesses.append(guess[ii])
                

        #search for remaining pegs with right color but wrong position
        for pi in remaining_patterns:
            if pi in remaining_guesses:
                x += 1
                remaining_guesses.remove(pi)
        return (x, y)

class ComputerPlayer(object):
    def __init__(self):
        self.unsolved_pegs = []
        self.solved_pegs = []
        self.solved_positions = set()
        self.colors = "rgoybp"
        self.unused_colors = list(self.colors)
        self.color_ind = -1
        self.total_positions_solved = 0
        self.colors_left_to_find = 4
        self.cur_unsolved_peg = None
        self.max_unsolved_pos = 3
        return

    def print_status(self):
        print 'unsolved pegs: %s'%self.unsolved_pegs
        print 'solved_pegs: %s'%self.solved_pegs
        print 'solved_positions: %s'%self.solved_positions
        print 'cur_color: %s'%self.colors[self.color_ind]
        print 'total_positions_solved: %s'%self.total_positions_solved
        print 'cur_unsolved_peg: %s'%self.cur_unsolved_peg

    def smart_guess(self):
        self.color_ind += 1
        #if self.color_ind >= len(self.colors):
        #    self.color_ind = len(self.colors) - 1
       

        if self.colors_left_to_find == 0:
            cur_color = self.unused_colors[0]
        else:
            cur_color = self.colors[self.color_ind]

        guess = [cur_color]*4

        for sp in self.solved_pegs:
            position = sp['position']
            color = sp['color']
            guess[position] = color

        if self.cur_unsolved_peg != None:
            guess[self.cur_unsolved_peg['position']] = self.cur_unsolved_peg['color'] 

        return ''.join(guess)

    def process_feedback(self, fb):
        x, y = fb
        z = x+y
        num_new_color_gains = z-self.total_positions_solved
        if self.cur_unsolved_peg != None:
            num_new_color_gains -= 1
        #for i in range(min(num_new_color_gains, self.colors_left_to_find)):
        for i in range(num_new_color_gains):
            posi = 0
            while posi in self.solved_positions:
                posi += 1
            self.unsolved_pegs.append({'color': self.colors[self.color_ind], 'position':posi, 'count':num_new_color_gains, 'exclude': set()})
            self.colors_left_to_find -= 1
            if self.colors[self.color_ind] in self.unused_colors:
                self.unused_colors.remove(self.colors[self.color_ind])

        if self.color_ind == len(self.colors) - 2:
            #shortcircuit: remaining colors must be of last color (purple)
            self.color_ind += 1
            tmp_colors_left_to_find = self.colors_left_to_find
            for i in range(tmp_colors_left_to_find):
                posi = 0
                while posi in self.solved_positions:
                    posi += 1
                self.unsolved_pegs.append({'color': self.colors[self.color_ind], 'position':posi, 'count':tmp_colors_left_to_find, 'exclude': set()})     
                self.colors_left_to_find -= 1
                if self.colors[self.color_ind] in self.unused_colors:
                    self.unused_colors.remove(self.colors[self.color_ind])

        
        self.unsolved_pegs.sort(key = lambda d:d['count'])

        if (y - self.total_positions_solved) == (num_new_color_gains + 1):
            self.solved_positions.add(self.cur_unsolved_peg['position'])
            self.total_positions_solved += 1
            self.max_unsolved_pos = max(pi for pi in range(4) if pi not in self.solved_positions) if self.total_positions_solved < 4 else -1 
            solved_peg_color = self.cur_unsolved_peg['color']
            for p in self.unsolved_pegs:
                if p['color'] == solved_peg_color:
                    p['count'] -= 1
            self.solved_pegs.append(self.cur_unsolved_peg)
            if len(self.unsolved_pegs) > 0:
                self.cur_unsolved_peg = self.unsolved_pegs.pop()
            else:
                self.cur_unsolved_peg = None
        else:
            if self.cur_unsolved_peg != None:
                for p in self.unsolved_pegs:
                    if p['color'] == self.cur_unsolved_peg['color']:
                        p['exclude'].add(self.cur_unsolved_peg['position'])
                self.cur_unsolved_peg['position'] += 1

        if self.cur_unsolved_peg == None and len(self.unsolved_pegs) > 0:
            self.cur_unsolved_peg = self.unsolved_pegs.pop()


        while (self.cur_unsolved_peg != None) and (self.churn_through_solved_positions() or self.short_circuit_last_position()):
            pass

        if self.cur_unsolved_peg != None:
            self.unsolved_pegs.append(self.cur_unsolved_peg)
            self.unsolved_pegs.sort(key = lambda d:d['count'])
            self.cur_unsolved_peg = self.unsolved_pegs.pop()
        return

    def churn_through_solved_positions(self):
        flag = False
        while (self.cur_unsolved_peg['position'] in self.solved_positions) or (self.cur_unsolved_peg['position'] in self.cur_unsolved_peg['exclude']):
            self.cur_unsolved_peg['position'] += 1
            flag = True
        return flag

    def short_circuit_last_position(self):
        flag = False
        if self.cur_unsolved_peg['position'] == self.max_unsolved_pos:
            self.solved_positions.add(self.cur_unsolved_peg['position'])
            self.total_positions_solved += 1
            self.max_unsolved_pos = max(pi for pi in range(4) if pi not in self.solved_positions) if self.total_positions_solved < 4 else -1 
            self.solved_pegs.append(self.cur_unsolved_peg)
            if len(self.unsolved_pegs) > 0:
                self.cur_unsolved_peg = self.unsolved_pegs.pop()
                
            else:
                self.cur_unsolved_peg = None
                
            flag = True
        return flag

def main():

    while True:
        human_input = raw_input("enter a pattern of 4 (repeatable) colors out of (r,g,o,y,b,p).  (ie. if (r,p,y,r), then enter \"rpyr\"): ").strip().replace(" ", "").replace(",", "")
        if len(human_input) != 4:
            print 'invalid input, please try again'
        else:
            break

    gc = GuessChecker(human_input)
    comp = ComputerPlayer()

    try_count = 0
    win_flag = False
    while (not win_flag) and (try_count < 10):
        guess = comp.smart_guess()
        print guess
        feedback = gc.check_guess(guess)
        print feedback
        comp.process_feedback(feedback)
        if feedback == (0,4):
            print 'Computer won:  correct guess=%s'%guess
            win_flag = True
            break

        try_count += 1
        comp.print_status()

    if win_flag == False:
        print 'You beat the computer!'
        

def randomized_tests():
    import random
    num_tests = 100
    colors = "rgoybp"
    colors_len = len(colors)
    for test_i in range(num_tests):
        human_input = ''.join([colors[random.randint(0,colors_len-1)] for i in range(4)]) 
        
        gc = GuessChecker(human_input)
        comp = ComputerPlayer()
        try_count = 0
        win_flag = False
        while (not win_flag) and (try_count < 10):
            guess = comp.smart_guess()
            feedback = gc.check_guess(guess)
            comp.process_feedback(feedback)
            if feedback == (0,4):
                win_flag = True
                break
            try_count += 1
        if win_flag:
            print 'Test %s: %s -- Passed'%(test_i, human_input)
        else:
            print 'Test %s: %s -- Failed!!!!'%(test_i, human_input)



#main()
randomized_tests()
